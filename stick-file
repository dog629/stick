import sys
import subprocess
import os

# --- STEP 1: AUTO-INSTALL REQUESTS ---
try:
    import requests
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "requests"])
    import requests

import tkinter as tk
from tkinter import messagebox
import math
import random
from datetime import datetime

# --- CONFIGURATION ---
VERSION = 1.0  
GITHUB_RAW_URL = "https://raw.githubusercontent.com/dog629/stick/main/stick-file"

# ---------------------------- #
# SYSTEM & FILE RESTART LOGIC
# ---------------------------- #
def restart_program():
    python = sys.executable
    os.execl(python, python, *sys.argv)

WIDTH, HEIGHT = 600, 500
TASKBAR_HEIGHT = 40

root_detect = tk.Tk()
SCREEN_WIDTH = root_detect.winfo_screenwidth()
SCREEN_HEIGHT = root_detect.winfo_screenheight()
root_detect.withdraw()

SCREEN_LOCK = False

# ---------------------------- #
# STICK FIGURE CLASS
# ---------------------------- #
class StickFigure:
    def __init__(self):
        self.x, self.y = 100, 300 
        self.dx, self.dy = random.uniform(-2, 2), random.uniform(-2, 2)
        self.step = 0
        self.message = ""
        self.timer = 0
        self.mode = "WANDER"
        self.has_greeted = False
        self.is_eating = False

    def update(self, current_win):
        now = datetime.now().hour
        self.step += 0.25 
        
        # 1. LOGIC STATES
        if self.mode == "GO_TO_PC":
            tx, ty = 125, 200 
            dist_x, dist_y = tx - self.x, ty - self.y
            self.dx, self.dy = dist_x / 10, dist_y / 15
            if abs(dist_x) < 5 and abs(dist_y) < 5:
                self.mode = "AT_MENU"
                self.dx, self.dy = 0, 0
                self.say("Connected!")
        
        elif now >= 21 or now < 6: # Sleep Mode
            self.mode = "SLEEP"
            self.x, self.y = 80, 300 
            self.dx, self.dy = 0, 0
            if self.timer == 0: self.message = "Zzz..."
        
        else: # Normal Daytime / Lunch
            self.mode = "WANDER"
            if 6 <= now < 11 and not self.has_greeted:
                self.say("Morning, human!")
                self.has_greeted = True
            elif 12 <= now < 14 and not self.is_eating:
                self.say("Mmm... lunch time!")
                self.is_eating = True

        # 2. MOVEMENT ENGINE (Only if wandering)
        if self.mode == "WANDER":
            if random.random() < 0.05: # Randomly change direction
                self.dx += random.uniform(-1, 1)
                self.dy += random.uniform(-1, 1)
            
            # Speed Caps
            self.dx = max(-4, min(4, self.dx))
            self.dy = max(-4, min(4, self.dy))

        self.x += self.dx
        self.y += self.dy

        # 3. WINDOW COLLISIONS
        win_x, win_y = current_win.winfo_x(), current_win.winfo_y()
        pushed_dx, pushed_dy = 0, 0
        
        if self.x <= 40: 
            self.x = 40; pushed_dx = -6; self.dx *= -1 
        if self.x >= WIDTH - 40: 
            self.x = WIDTH - 40; pushed_dx = 6; self.dx *= -1
        if self.y <= 60: 
            self.y = 60; pushed_dy = -6; self.dy *= -1
        if self.y >= HEIGHT - 130: 
            self.y = HEIGHT - 130; pushed_dy = 6; self.dy *= -1

        # 4. MONITOR LOCK LOGIC
        new_x = win_x + pushed_dx
        new_y = win_y + pushed_dy
        
        if SCREEN_LOCK:
            new_x = max(0, min(SCREEN_WIDTH - WIDTH, new_x))
            new_y = max(0, min(SCREEN_HEIGHT - HEIGHT - TASKBAR_HEIGHT, new_y))
            
        current_win.geometry(f"+{int(new_x)}+{int(new_y)}")
        
        if self.timer > 0:
            self.timer -= 1
            if self.timer == 0: self.message = ""

    def say(self, text):
        self.message = text
        self.timer = 150

# ---------------------------- #
# GAME MENU CLASS
# ---------------------------- #
class GameMenu:
    def __init__(self):
        self.window = tk.Toplevel()
        self.window.title("Control Panel")
        self.window.geometry("280x500+450+300")
        self.window.configure(bg="#1a1a1a")
        self.window.attributes('-topmost', True)
        
        tk.Label(self.window, text="SYSTEM STATUS", fg="gray", bg="#1a1a1a").pack(pady=5)
        self.status_label = tk.Label(self.window, text="IDLE", fg="white", bg="#1a1a1a", font=("Arial", 12, "bold"))
        self.status_label.pack()

        self.time_label = tk.Label(self.window, text="", fg="cyan", bg="#1a1a1a", font=("Consolas", 10))
        self.time_label.pack(pady=5)

        self.connect_btn = tk.Button(self.window, text="CONNECT TO PC", width=20, command=self.handle_connect)
        self.connect_btn.pack(pady=10)

        # MONITOR CONTROL SECTION
        tk.Label(self.window, text="--- MONITOR CONTROL ---", fg="gray", bg="#1a1a1a").pack(pady=10)
        self.lock_var = tk.BooleanVar(value=False)
        self.lock_cb = tk.Checkbutton(self.window, text="Lock to Screen 1", variable=self.lock_var, 
                                      command=self.toggle_lock, bg="#1a1a1a", fg="white", 
                                      selectcolor="#333", activebackground="#1a1a1a")
        self.lock_cb.pack()

        # UPDATE SECTION
        tk.Label(self.window, text="--- SYSTEM ---", fg="gray", bg="#1a1a1a").pack(pady=10)
        self.update_btn = tk.Button(self.window, text=f"v{VERSION} - Up to Date", bg="#111", fg="gray", state="disabled")
        self.update_btn.pack(pady=5)
        
        tk.Button(self.window, text="RESTART", bg="#3d1414", fg="white", command=restart_program).pack(pady=5)

        self.auto_loop()

    def check_for_global_update(self):
        try:
            nocache = random.randint(1, 99999)
            url = f"{GITHUB_RAW_URL}?nocache={nocache}"
            resp = requests.get(url, timeout=5)
            remote_v = VERSION
            for line in resp.text.split('\n'):
                if "VERSION =" in line:
                    remote_v = float(line.split('=')[1].strip())
                    break
            if remote_v > VERSION:
                self.update_btn.config(text=f"UPDATE TO v{remote_v}", bg="cyan", fg="black", state="normal", 
                                       command=lambda: self.apply_update(resp.text))
        except: pass

    def apply_update(self, new_code):
        if messagebox.askyesno("Update", "Install update?"):
            with open(os.path.abspath(sys.argv[0]), "w", encoding="utf-8") as f:
                f.write(new_code)
            restart_program()

    def toggle_lock(self):
        global SCREEN_LOCK
        SCREEN_LOCK = self.lock_var.get()

    def handle_connect(self):
        if current_world == house:
            stick.mode = "GO_TO_PC"
            self.status_label.config(text="CONNECTING...", fg="yellow")
            self.check_arrival()
        else: stick.say("Get inside first!")

    def check_arrival(self):
        if stick.mode == "AT_MENU":
            self.status_label.config(text="ONLINE", fg="lime")
            self.connect_btn.config(state="disabled", text="CONNECTED")
        else: self.window.after(100, self.check_arrival)

    def auto_loop(self):
        self.time_label.config(text=datetime.now().strftime("%H:%M:%S"))
        if int(datetime.now().strftime("%S")) % 15 == 0:
            self.check_for_global_update()
        self.window.after(1000, self.auto_loop)

# ---------------------------- #
# WORLD SETUP
# ---------------------------- #
class World:
    def __init__(self, title, x, is_house=False):
        self.window = tk.Toplevel(); self.window.title(title); self.window.geometry(f"{WIDTH}x{HEIGHT}+{x}+200")
        self.window.configure(bg="black"); self.is_house = is_house
        self.canvas = tk.Canvas(self.window, width=WIDTH, height=HEIGHT, bg="black", highlightthickness=0); self.canvas.pack()
        self.entry = tk.Entry(self.window, font=("Arial", 12), bg="#111", fg="white"); self.entry.place(x=10, y=HEIGHT-35, width=WIDTH-20)

    def draw_decorations(self):
        if self.is_house:
            self.canvas.create_rectangle(30, 350, 150, 400, fill="#444") # Bed
            self.canvas.create_rectangle(110, 200, 140, 240, fill="#002244") # PC

    def clear(self): self.canvas.delete("all"); self.draw_decorations()
    
    def draw_stick(self, s):
        c = self.canvas; cx, cy = s.x, s.y
        c.create_oval(cx-15, cy-45, cx+15, cy-15, outline="white", width=3) # Head
        c.create_line(cx, cy-15, cx, cy+60, fill="white", width=3) # Body
        arm = math.sin(s.step) * 20
        c.create_line(cx, cy+10, cx-40, cy+40+arm, fill="white", width=3) 
        c.create_line(cx, cy+10, cx+40, cy+40-arm, fill="white", width=3)
        leg = math.sin(s.step) * 25
        c.create_line(cx, cy+60, cx-25, cy+120-leg, fill="white", width=3) 
        c.create_line(cx, cy+60, cx+25, cy+120+leg, fill="white", width=3)
        if s.message:
            c.create_rectangle(cx-80, cy-110, cx+80, cy-60, fill="white")
            c.create_text(cx, cy-85, text=s.message, fill="black", font=("Arial", 9, "bold"))

root = tk.Tk(); root.withdraw()
outside = World("Outside", 100); house = World("House", 800, is_house=True)
stick = StickFigure(); current_world = outside
house.entry.place_forget()
menu = GameMenu()

def handle_chat(event, world):
    global current_world
    text = world.entry.get().strip().lower(); world.entry.delete(0, tk.END)
    if "come in" in text:
        outside.entry.place_forget(); house.entry.place(x=10, y=HEIGHT-35, width=WIDTH-20)
        current_world = house
    elif "come out" in text:
        house.entry.place_forget(); outside.entry.place(x=10, y=HEIGHT-35, width=WIDTH-20)
        current_world = outside
    else: stick.say("Thinking...")

outside.entry.bind("<Return>", lambda e: handle_chat(e, outside))
house.entry.bind("<Return>", lambda e: handle_chat(e, house))

def loop():
    stick.update(current_world.window)
    outside.clear(); house.clear()
    current_world.draw_stick(stick)
    root.after(30, loop)

loop(); root.mainloop()
